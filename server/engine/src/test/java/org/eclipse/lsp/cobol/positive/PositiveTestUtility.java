/*
 * Copyright (c) 2021 Broadcom.
 * The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *    Broadcom, Inc. - initial API and implementation
 *
 */
package org.eclipse.lsp.cobol.positive;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import lombok.experimental.UtilityClass;
import org.eclipse.lsp.cobol.common.model.Locality;
import org.eclipse.lsp.cobol.common.model.NodeType;
import org.eclipse.lsp.cobol.common.model.tree.CopyNode;
import org.eclipse.lsp.cobol.common.model.tree.Node;
import org.eclipse.lsp.cobol.common.model.tree.ProgramNode;
import org.eclipse.lsp.cobol.common.model.tree.variable.VariableNode;
import org.eclipse.lsp.cobol.common.symbols.CodeBlockReference;
import org.eclipse.lsp.cobol.common.symbols.SymbolTable;
import org.eclipse.lsp.cobol.common.utils.ImplicitCodeUtils;
import org.eclipse.lsp.cobol.core.engine.symbols.SymbolsRepository;
import org.eclipse.lsp4j.Location;
import org.eclipse.lsp4j.Range;
import org.junit.jupiter.api.Assertions;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.lang.System.getProperty;
import static java.util.Collections.emptyList;
import static java.util.Optional.empty;
import static java.util.Optional.ofNullable;
import static java.util.stream.Collectors.toList;

/** Utility class for Positive Tests. */
@UtilityClass
public class PositiveTestUtility {
    private final List<String> blacklistedTestFiles =
            Arrays.asList("DB1054.2.cbl",
                    "EXEC84.2.cbl",
                    "IF1054.2.cbl",
                    "IF1194.2.cbl",
                    "IF1234.2.cbl",
                    "IF1274.2.cbl",
                    "IF1284.2.cbl",
                    "IF1294.2.cbl",
                    "IX1114.2.cbl",
                    "IX2104.2.cbl",
                    "IX2124.2.cbl",
                    "IX2144.2.cbl",
                    "IX2154.2.cbl",
                    "IX2184.2.cbl",
                    "NC1354.2.cbl",
                    "NC2024.2.cbl",
                    "NC2054.2.cbl",
                    "NC2074.2.cbl",
                    "NC2084.2.cbl",
                    "NC2094.2.cbl",
                    "NC2144.2.cbl",
                    "NC2154.2.cbl",
                    "NC2194.2.cbl",
                    "NC2224.2.cbl",
                    "NC2504.2.cbl",
                    "NC2524.2.cbl",
                    "NC2534.2.cbl",
                    "SM1064.2.cbl",
                    "SM1074.2.cbl");

  /**
   * Assets DataName, procedure and program definition and references matches from the listing
   * provided by compiler.
   *
   * @param symbolTableMap a map with symbol tables
   * @param dataNameRefs References from the listing
   * @param rootNode root Node generated by LSP engine
   * @param fileName test file
   */
  void assetDefinitionsNReferencesFromSnap(
      Map<String, SymbolTable> symbolTableMap,
      Map<ReportSection, List<SysprintSnap>> dataNameRefs,
      Node rootNode,
      String fileName) {
    if (blacklistedTestFiles.contains(fileName)) return;
    Multimap<String, Node> variableDefinitionFromLSPEngine = ArrayListMultimap.create();
    Multimap<String, CodeBlockReference> paragraphDefFromLSPEngine = ArrayListMultimap.create();
    Multimap<String, Node> programDefinitionFromLSPEngine = ArrayListMultimap.create();

    fetchReferencesFromLSPEngine(
        rootNode,
            symbolTableMap,
        variableDefinitionFromLSPEngine,
        paragraphDefFromLSPEngine,
        programDefinitionFromLSPEngine);
    assertDataName(
        dataNameRefs.getOrDefault(ReportSection.DATA_NAMES, Collections.emptyList()),
        variableDefinitionFromLSPEngine,
        fileName);
    assertProcedures(
        dataNameRefs.getOrDefault(ReportSection.PROCEDURES, Collections.emptyList()),
        paragraphDefFromLSPEngine,
        fileName);
    assertPrograms(
        dataNameRefs.getOrDefault(ReportSection.PROGRAMS, emptyList()),
        programDefinitionFromLSPEngine,
        fileName);
  }

  private void assertPrograms(
      List<SysprintSnap> allProgRef,
      Multimap<String, Node> programDefinitionFromLSPEngine,
      String fileName) {
    allProgRef.forEach(
        prog -> {
          String dataName = prog.getDataName();
          Optional<Node> progNode =
              programDefinitionFromLSPEngine.get(dataName).stream().findFirst();
          Assertions.assertTrue(
              progNode.isPresent(),
              "[" + fileName + "]:" + "Program definition not found for " + dataName);
          // TODO: Do not match line number as program Node always starts from 0 for LSP
          // Assertions.assertEquals(prog.getDefinedLineNo(),
          // progNode.get().getLocality().getRange().getStart().getLine() + 1);
        });
  }

  private void assertProcedures(
      List<SysprintSnap> sysprintSnaps,
      Multimap<String, CodeBlockReference> paragraphDefFromLSPEngine,
      String fileName) {
    sysprintSnaps.forEach(
        snap -> {
          String dataName = snap.getDataName();
          Optional<Map.Entry<List<Location>, List<Location>>> foundElementFromLSPEngine =
              paragraphDefFromLSPEngine.get(dataName).stream()
                  .map(node -> Collections.singletonMap(node.getDefinitions(), node.getUsage()))
                  .map(Map::entrySet)
                  .flatMap(Collection::stream)
                  .filter(ref -> matchParagraphDefinition(snap, ref))
                  .findFirst();
          Assertions.assertTrue(
              foundElementFromLSPEngine.isPresent(),
              "["
                  + fileName
                  + "]:"
                  + "Procedure definition for "
                  + dataName
                  + " not found in LSP engine");
          List<Location> nodes = foundElementFromLSPEngine.get().getValue();
          assertReferencesByProcedures(snap, nodes, fileName);

          // TODO : Update snap object when flag provided
          snap.setDefinitionLocation(foundElementFromLSPEngine.get().getKey().get(0).getRange());
          snap.setReferencesLocation(nodes.stream().map(Location::getRange).collect(toList()));
        });
  }

  private boolean matchParagraphDefinition(
      SysprintSnap snap, Map.Entry<List<Location>, List<Location>> ref) {
    if (snap.getDefinitionLocation() != null) {
      return ref.getKey().stream()
          .anyMatch(node -> snap.getDefinitionLocation().equals(node.getRange()));
    }
    return ref.getKey().stream()
        .anyMatch(node -> node.getRange().getStart().getLine() + 1 == snap.getDefinedLineNo());
  }

  private void assertReferencesByProcedures(
      SysprintSnap snap, List<Location> lspNodes, String fileName) {
    List<Integer> referencesFromLSPEngine =
        lspNodes.stream()
            .map(loc -> loc.getRange().getStart().getLine() + 1)
            .collect(Collectors.toList());
    if (snap.getReferencesLocation() != null) {
      snap.getReferencesLocation()
          .forEach(
              snapRef -> {
                boolean match = lspNodes.stream().map(Location::getRange).anyMatch(snapRef::equals);
                Assertions.assertTrue(
                    match,
                    "["
                        + fileName
                        + "]:"
                        + "Procedure snapReferences for "
                        + snap.getDataName()
                        + " not found at line no: "
                        + snapRef);
              });
    } else {
      snap.getReferences()
          .forEach(
              ref ->
                  Assertions.assertTrue(
                      referencesFromLSPEngine.contains(ref),
                      "["
                          + fileName
                          + "]:"
                          + "Procedure snapReferences for "
                          + snap.getDataName()
                          + " not found at line no: "
                          + ref));
    }
  }

  private void assertDataName(
      List<SysprintSnap> dataNameRefs,
      Multimap<String, Node> variableDefinitionFromLSPEngine,
      String fileName) {
    dataNameRefs.forEach(
        snap -> {
          String dataName = snap.getDataName();
          Collection<Node> nodes = variableDefinitionFromLSPEngine.get(dataName);
          if (Objects.nonNull(snap.getDefinitionLocation())) {
            assertSnapRangeReferencesByDataName(snap, nodes, fileName);
          } else {
            assertReferencesByDataName(snap, nodes, fileName);
          }
        });
  }

  private void assertSnapRangeReferencesByDataName(
      SysprintSnap snap, Collection<Node> nodes, String fileName) {
    Optional<VariableNode> foundVariableNodeInLSP =
        nodes.stream()
            .filter(node -> snap.getDefinitionLocation().equals(node.getLocality().getRange()))
            .findFirst()
            .filter(VariableNode.class::isInstance)
            .map(VariableNode.class::cast);

    List<Range> ranges =
        nodes.stream()
            .filter(VariableNode.class::isInstance)
            .map(VariableNode.class::cast)
            .filter(node -> node.getName().equals(snap.getDataName()))
            .map(node -> node.getLocality().getRange())
            .collect(toList());

    Assertions.assertTrue(
        foundVariableNodeInLSP.isPresent(),
        "["
            + fileName
            + "]:"
            + "Data name definition for "
            + snap.getDataName()
            + " expected range: \r\n"
            + snap.getDefinitionLocation()
            + " but found: \r\n"
            + ranges);

    foundVariableNodeInLSP.ifPresent(
        node -> {
          List<Range> usagesFromEngine =
              node.getUsages().stream().map(Location::getRange).collect(Collectors.toList());

          List<Range> unmatchedReferences =
              snap.getReferencesLocation().stream()
                  .filter(snapRange -> !usagesFromEngine.contains(snapRange))
                  .collect(toList());

          Assertions.assertEquals(
              0,
              unmatchedReferences.size(),
              "["
                  + fileName
                  + "]:"
                  + "Data references are not found for "
                  + snap.getDataName()
                  + ", at: "
                  + unmatchedReferences.stream()
                      .map(Object::toString)
                      .collect(Collectors.joining(" ,")));
        });
  }

  private void assertReferencesByDataName(
    SysprintSnap snap, Collection<Node> nodes, String fileName) {
      Optional<Node> first = nodes.stream()
              .filter(node -> {
                  Locality locality = node.getLocality();
                  boolean isImplicit = ImplicitCodeUtils.isImplicit(locality.getUri());
                  int definedLineNo = snap.getDefinedLineNo(); // implicit nodes are always at line 0
                  return (isImplicit && definedLineNo == 0) ||
                          locality.toLocation().getRange().getStart().getLine() + 1 == definedLineNo;
              })
              .findFirst();

    Optional<VariableNode> foundVariableNodeInLSP =
        first
            .filter(VariableNode.class::isInstance)
            .map(VariableNode.class::cast);

    Assertions.assertTrue(
        foundVariableNodeInLSP.isPresent(),
        "["
            + fileName
            + "]:"
            + "Data name definition for "
            + snap.getDataName()
            + " not found in LSP engine");

    foundVariableNodeInLSP.ifPresent(
        node -> {
          List<Object> usagesFromEngine =
              node.getUsages().stream()
                  .flatMap(usage -> {
                      if (usage.getUri().contains(fileName)) {
                          return Stream.of(usage.getRange().getStart().getLine() + 1);
                      } else {
                          // seems a copybook
                          return getCopyBookLineNumber(node, usage).stream().map(x -> x + usage.getRange().getStart().getLine() + 1) ;
                      }
                  })
                  .collect(Collectors.toList());

          List<Integer> unmatchedReferences =
              snap.getReferences().stream()
                  .filter(lineNo -> !usagesFromEngine.contains(lineNo))
                  .collect(Collectors.toList());

          Assertions.assertEquals(
              0,
              unmatchedReferences.size(),
              "["
                  + fileName
                  + "]:"
                  + "Data references are not found for "
                  + snap.getDataName()
                  + ", at: "
                  + unmatchedReferences.stream()
                      .map(Object::toString)
                      .collect(Collectors.joining(" ,")));

          String updateFlag = ofNullable(getProperty("UpdateSnapListing")).orElse("false");
          if (!updateFlag.equals("false")) {
            Range location = foundVariableNodeInLSP.get().getLocality().getRange();
            List<Range> collect =
                node.getUsages().stream().map(Location::getRange).collect(toList());
            snap.setReferencesLocation(collect);
            snap.setDefinitionLocation(location);
          }
        });
  }

    private List<Integer> getCopyBookLineNumber(Node node, Location usage) {
        return node.getNearestParentByType(NodeType.PROGRAM)
                .map(x -> x.getDepthFirstStream()
                .filter(n1 -> n1.getNodeType() == NodeType.COPY)
                .map(CopyNode.class::cast)
                .filter(n2 -> n2.getUri().equals(usage.getUri()))
                .collect(toList())).orElse(emptyList())
                .stream().map(n -> n.getLocality().getRange().getEnd().getLine() + 1)
                .collect(toList());
    }

  private void fetchReferencesFromLSPEngine(
      Node rootNode,
      Map<String, SymbolTable> symbolTableMap,
      Multimap<String, Node> variableDefinitionFromLSPEngine,
      Multimap<String, CodeBlockReference> paragraphDefFromLSPEngine,
      Multimap<String, Node> programDefinitionFromLSPEngine) {
      SymbolsRepository repo = new SymbolsRepository();
      repo.updateSymbols(symbolTableMap);
    rootNode
        .getDepthFirstStream()
        .filter(node -> node.getNodeType() == NodeType.PROGRAM)
        .map(ProgramNode.class::cast)
        .forEach(
            programNode -> {
              Stream.of(
                      repo.getParagraphMap(programNode),
                      repo.getSectionMap(programNode))
                  .flatMap(entry -> entry.entrySet().stream())
                  .forEach(
                      entry -> paragraphDefFromLSPEngine.put(entry.getKey(), entry.getValue()));

              repo.getVariables(programNode).values().stream()
                  .flatMap(Node::getDepthFirstStream)
                  .filter(VariableNode.class::isInstance)
                  .map(VariableNode.class::cast)
                  .distinct()
                  .forEach(entry -> variableDefinitionFromLSPEngine.put(entry.getName(), entry));
              programDefinitionFromLSPEngine.put(
                  programNode.getProgramName().toUpperCase(Locale.ROOT), programNode);
            });
  }
}
