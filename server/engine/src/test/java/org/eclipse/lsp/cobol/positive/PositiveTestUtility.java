/*
 * Copyright (c) 2021 Broadcom.
 * The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *    Broadcom, Inc. - initial API and implementation
 *
 */
package org.eclipse.lsp.cobol.positive;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import lombok.experimental.UtilityClass;
import org.eclipse.lsp.cobol.core.engine.symbols.CodeBlockReference;
import org.eclipse.lsp.cobol.core.engine.symbols.SymbolService;
import org.eclipse.lsp.cobol.core.model.tree.Node;
import org.eclipse.lsp.cobol.core.model.tree.NodeType;
import org.eclipse.lsp.cobol.core.model.tree.ProgramNode;
import org.eclipse.lsp.cobol.core.model.tree.variables.VariableNode;
import org.eclipse.lsp4j.Location;
import org.eclipse.lsp4j.Range;
import org.junit.jupiter.api.Assertions;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.lang.System.getProperty;
import static java.util.Collections.emptyList;
import static java.util.Optional.ofNullable;
import static java.util.stream.Collectors.toList;

/** Utility class for Positive Tests. */
@UtilityClass
public class PositiveTestUtility {

  private final List<String> blacklistedTestFiles =
      Arrays.asList(
          "DB1014.2.cbl",
          "DB1024.2.cbl",
          "DB1044.2.cbl",
          "DB1054.2.cbl",
          "EXEC84.2.cbl",
          "IF1054.2.cbl",
          "IF1194.2.cbl",
          "IF1234.2.cbl",
          "IF1274.2.cbl",
          "IF1284.2.cbl",
          "IF1294.2.cbl",
          "IX1114.2.cbl",
          "IX2104.2.cbl",
          "IX2124.2.cbl",
          "IX2144.2.cbl",
          "IX2154.2.cbl",
          "IX2184.2.cbl",
          "NC1354.2.cbl",
          "NC2024.2.cbl",
          "NC2054.2.cbl",
          "NC2074.2.cbl",
          "NC2084.2.cbl",
          "NC2094.2.cbl",
          "NC2144.2.cbl",
          "NC2154.2.cbl",
          "NC2194.2.cbl",
          "NC2224.2.cbl",
          "NC2504.2.cbl",
          "NC2524.2.cbl",
          "NC2534.2.cbl",
          "SM1064.2.cbl",
          "SM1074.2.cbl");

  /**
   * Assets DataName, procedure and program definition and references matches from the listing
   * provided by compiler.
   *
   * @param symbolService a Symbol Service
   * @param dataNameRefs References from the listing
   * @param rootNode root Node generated by LSP engine
   * @param fileName test file
   */
  void assetDefinitionsNReferencesFromSnap(
      SymbolService symbolService,
      Map<ReportSection, List<SysprintSnap>> dataNameRefs,
      Node rootNode,
      String fileName) {
    if (blacklistedTestFiles.contains(fileName)) return;
    Multimap<String, Node> variableDefinitionFromLSPEngine = ArrayListMultimap.create();
    Multimap<String, CodeBlockReference> paragraphDefFromLSPEngine = ArrayListMultimap.create();
    Multimap<String, Node> programDefinitionFromLSPEngine = ArrayListMultimap.create();

    fetchReferencesFromLSPEngine(
        rootNode,
        symbolService,
        variableDefinitionFromLSPEngine,
        paragraphDefFromLSPEngine,
        programDefinitionFromLSPEngine);
    assertDataName(
        dataNameRefs.getOrDefault(ReportSection.DATA_NAMES, Collections.emptyList()),
        variableDefinitionFromLSPEngine,
        fileName);
    assertProcedures(
        dataNameRefs.getOrDefault(ReportSection.PROCEDURES, Collections.emptyList()),
        paragraphDefFromLSPEngine,
        fileName);
    assertPrograms(
        dataNameRefs.getOrDefault(ReportSection.PROGRAMS, emptyList()),
        programDefinitionFromLSPEngine,
        fileName);
  }

  private void assertPrograms(
      List<SysprintSnap> allProgRef,
      Multimap<String, Node> programDefinitionFromLSPEngine,
      String fileName) {
    allProgRef.forEach(
        prog -> {
          String dataName = prog.getDataName();
          Optional<Node> progNode =
              programDefinitionFromLSPEngine.get(dataName).stream().findFirst();
          Assertions.assertTrue(
              progNode.isPresent(),
              "[" + fileName + "]:" + "Program definition not found for " + dataName);
          // TODO: Do not match line number as program Node always starts from 0 for LSP
          // Assertions.assertEquals(prog.getDefinedLineNo(),
          // progNode.get().getLocality().getRange().getStart().getLine() + 1);
        });
  }

  private void assertProcedures(
      List<SysprintSnap> sysprintSnaps,
      Multimap<String, CodeBlockReference> paragraphDefFromLSPEngine,
      String fileName) {
    sysprintSnaps.forEach(
        snap -> {
          String dataName = snap.getDataName();
          Optional<Map.Entry<List<Location>, List<Location>>> foundElementFromLSPEngine =
              paragraphDefFromLSPEngine.get(dataName).stream()
                  .map(node -> Collections.singletonMap(node.getDefinitions(), node.getUsage()))
                  .map(Map::entrySet)
                  .flatMap(Collection::stream)
                  .filter(ref -> matchParagraphDefinition(snap, ref))
                  .findFirst();
          Assertions.assertTrue(
              foundElementFromLSPEngine.isPresent(),
              "["
                  + fileName
                  + "]:"
                  + "Procedure definition for "
                  + dataName
                  + " not found in LSP engine");
          List<Location> nodes = foundElementFromLSPEngine.get().getValue();
          assertReferencesByProcedures(snap, nodes, fileName);

          // TODO : Update snap object when flag provided
          snap.setDefinitionLocation(foundElementFromLSPEngine.get().getKey().get(0).getRange());
          snap.setReferencesLocation(nodes.stream().map(Location::getRange).collect(toList()));
        });
  }

  private boolean matchParagraphDefinition(
      SysprintSnap snap, Map.Entry<List<Location>, List<Location>> ref) {
    if (snap.getDefinitionLocation() != null) {
      return ref.getKey().stream()
          .anyMatch(node -> snap.getDefinitionLocation().equals(node.getRange()));
    }
    return ref.getKey().stream()
        .anyMatch(node -> node.getRange().getStart().getLine() + 1 == snap.getDefinedLineNo());
  }

  private void assertReferencesByProcedures(
      SysprintSnap snap, List<Location> lspNodes, String fileName) {
    List<Integer> referencesFromLSPEngine =
        lspNodes.stream()
            .map(loc -> loc.getRange().getStart().getLine() + 1)
            .collect(Collectors.toList());
    if (snap.getReferencesLocation() != null) {
      snap.getReferencesLocation()
          .forEach(
              snapRef -> {
                boolean match = lspNodes.stream().map(Location::getRange).anyMatch(snapRef::equals);
                Assertions.assertTrue(
                    match,
                    "["
                        + fileName
                        + "]:"
                        + "Procedure snapReferences for "
                        + snap.getDataName()
                        + " not found at line no: "
                        + snapRef);
              });
    } else {
      snap.getReferences()
          .forEach(
              ref ->
                  Assertions.assertTrue(
                      referencesFromLSPEngine.contains(ref),
                      "["
                          + fileName
                          + "]:"
                          + "Procedure snapReferences for "
                          + snap.getDataName()
                          + " not found at line no: "
                          + ref));
    }
  }

  private void assertDataName(
      List<SysprintSnap> dataNameRefs,
      Multimap<String, Node> variableDefinitionFromLSPEngine,
      String fileName) {
    dataNameRefs.forEach(
        snap -> {
          String dataName = snap.getDataName();
          Collection<Node> nodes = variableDefinitionFromLSPEngine.get(dataName);
          if (Objects.nonNull(snap.getDefinitionLocation())) {
            assertSnapRangeReferencesByDataName(snap, nodes, fileName);
          } else {
            assertReferencesByDataName(snap, nodes, fileName);
          }
        });
  }

  private void assertSnapRangeReferencesByDataName(
      SysprintSnap snap, Collection<Node> nodes, String fileName) {
    Optional<VariableNode> foundVariableNodeInLSP =
        nodes.stream()
            .filter(node -> snap.getDefinitionLocation().equals(node.getLocality().getRange()))
            .findFirst()
            .filter(VariableNode.class::isInstance)
            .map(VariableNode.class::cast);

    List<Range> ranges =
        nodes.stream()
            .filter(VariableNode.class::isInstance)
            .map(VariableNode.class::cast)
            .filter(node -> node.getName().equals(snap.getDataName()))
            .map(node -> node.getLocality().getRange())
            .collect(toList());

    Assertions.assertTrue(
        foundVariableNodeInLSP.isPresent(),
        "["
            + fileName
            + "]:"
            + "Data name definition for "
            + snap.getDataName()
            + " not found in LSP engine. Ranges: \r\n"
            + ranges);

    foundVariableNodeInLSP.ifPresent(
        node -> {
          List<Range> usagesFromEngine =
              node.getUsages().stream().map(Location::getRange).collect(Collectors.toList());

          List<Range> unmatchedReferences =
              snap.getReferencesLocation().stream()
                  .filter(snapRange -> !usagesFromEngine.contains(snapRange))
                  .collect(toList());

          Assertions.assertEquals(
              0,
              unmatchedReferences.size(),
              "["
                  + fileName
                  + "]:"
                  + "Data references are not found for "
                  + snap.getDataName()
                  + ", at: "
                  + unmatchedReferences.stream()
                      .map(Object::toString)
                      .collect(Collectors.joining(" ,")));
        });
  }

  private void assertReferencesByDataName(
      SysprintSnap snap, Collection<Node> nodes, String fileName) {
    Optional<VariableNode> foundVariableNodeInLSP =
        nodes.stream()
            .filter(
                node ->
                    node.getLocality().toLocation().getRange().getStart().getLine() + 1
                        == snap.getDefinedLineNo())
            .findFirst()
            .filter(VariableNode.class::isInstance)
            .map(VariableNode.class::cast);
    Assertions.assertTrue(
        foundVariableNodeInLSP.isPresent(),
        "["
            + fileName
            + "]:"
            + "Data name definition for "
            + snap.getDataName()
            + " not found in LSP engine");

    foundVariableNodeInLSP.ifPresent(
        node -> {
          List<Object> usagesFromEngine =
              node.getUsages().stream()
                  .map(usage -> usage.getRange().getStart().getLine() + 1)
                  .collect(Collectors.toList());

          List<Integer> unmatchedReferences =
              snap.getReferences().stream()
                  .filter(lineNo -> !usagesFromEngine.contains(lineNo))
                  .collect(Collectors.toList());

          Assertions.assertEquals(
              0,
              unmatchedReferences.size(),
              "["
                  + fileName
                  + "]:"
                  + "Data references are not found for "
                  + snap.getDataName()
                  + ", at: "
                  + unmatchedReferences.stream()
                      .map(Object::toString)
                      .collect(Collectors.joining(" ,")));

          String updateFlag = ofNullable(getProperty("UpdateSnapListing")).orElse("false");
          if (!updateFlag.equals("false")) {
            Range location = foundVariableNodeInLSP.get().getLocality().getRange();
            List<Range> collect =
                node.getUsages().stream().map(Location::getRange).collect(toList());
            snap.setReferencesLocation(collect);
            snap.setDefinitionLocation(location);
          }
        });
  }

  private void fetchReferencesFromLSPEngine(
      Node rootNode,
      SymbolService symbolService,
      Multimap<String, Node> variableDefinitionFromLSPEngine,
      Multimap<String, CodeBlockReference> paragraphDefFromLSPEngine,
      Multimap<String, Node> programDefinitionFromLSPEngine) {
    rootNode
        .getDepthFirstStream()
        .filter(node -> node.getNodeType() == NodeType.PROGRAM)
        .map(ProgramNode.class::cast)
        .forEach(
            programNode -> {
              Stream.of(
                      symbolService.getParagraphMap(programNode),
                      symbolService.getSectionMap(programNode))
                  .flatMap(entry -> entry.entrySet().stream())
                  .forEach(
                      entry -> paragraphDefFromLSPEngine.put(entry.getKey(), entry.getValue()));

              programNode.getVariables().values().stream()
                  .flatMap(Node::getDepthFirstStream)
                  .filter(VariableNode.class::isInstance)
                  .map(VariableNode.class::cast)
                  .forEach(entry -> variableDefinitionFromLSPEngine.put(entry.getName(), entry));
              programDefinitionFromLSPEngine.put(
                  programNode.getProgramName().toUpperCase(Locale.ROOT), programNode);
            });
  }
}
